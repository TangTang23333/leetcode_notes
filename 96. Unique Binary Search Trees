96. Unique Binary Search Trees
Medium

5577

206

Add to List

Share
Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.




========= DFS ============================
class Solution:
    def numTrees(self, n: int) -> int:
        if not n: return 0 
        if n == 1: return 1 
        return self.dfs(1, n)
        
        
    
    
    def dfs(self, start, n):
        # exit 
        if start >= n:
            return 1 
   
        
        res = 0
        for i in range(start, n+1):
            # i is root , find left and right for BST
            res +=  self.dfs(start, i-1) * self.dfs(i+1, n)
           
        return res 
        
                    
=============DP ==============================
class Solution:
    def numTrees(self, n: int) -> int:
        if not n: return 0 
        if n == 1: return 1 
        
        
        dp = [0] * (n+1)
        dp[0] = 1
        dp[1] = 1
        
        for i in range(2,n+1):
            for j in range(1, i+1):
                # all: 1-i, root: j with j nodes,  left: 1:j-1 with (j-1) nodes, right: j+1 with (i-j) nodes 
                dp[i] += dp[j-1] * dp[i-j] 
                
              
        return dp[-1]
        
                    
# Memo:
- dfs can be very time consuming 
- dp --> O(n**2) 
- it depends on combination of left child and right child, null is one, not zero
